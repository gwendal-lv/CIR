import os
import re
import shutil
import subprocess
import tempfile
import threading
import time
import warnings
from contextlib import contextmanager
from pathlib import Path
from typing import Dict, Optional, Callable

import torch
from tqdm import tqdm


def get_git_info() -> Dict[str, str]:
    """Retrieve git status information using subprocess."""
    git_commands = {
        "remote_url": ["git", "config", "--get", "remote.origin.url"],
        "branch_name": ["git", "rev-parse", "--abbrev-ref", "HEAD"],
        "commit_hash": ["git", "rev-parse", "HEAD"]
    }
    git_info = {}
    try:
        for key, cmd in git_commands.items():
            proc = subprocess.run(cmd, capture_output=True, text=True, check=False)
            git_info[key] = proc.stdout.strip() if proc.returncode == 0 else "unknown"
    except Exception as e:
        print(f"Error retrieving git info: {e}")
        git_info = {key: "unknown" for key in git_commands}
    return git_info


def sanitize_file_name(name):
    # Define a regex pattern to match problematic characters
    pattern = r'[\\/*?%|"<>:]'
    problematic_chars = re.findall(pattern, name)
    if problematic_chars:
        # Create a safe version of the directory name by replacing problematic characters with an underscore
        safe_name = re.sub(pattern, '_', name)
        warnings.warn(f"The directory name contained the following problematic characters: {set(problematic_chars)}. "
                      f"They have been replaced with underscores. New directory name: {safe_name}.")
        return safe_name
    else:
        return name


def save_pytorch_data_safely(data, file_path):
    """ Crash-proof save (won't save anything until the file is fully written to disk). """
    # Create a temporary file that will be automatically closed when the with block exits
    with tempfile.NamedTemporaryFile(delete=False, delete_on_close=False) as temp_file:
        temp_file_path = temp_file.name
    try:
        # Save PyTorch data to the temporary file, and move it to the final destination
        torch.save(data, temp_file_path)
        shutil.move(temp_file_path, file_path)
    except Exception as e:
        os.remove(temp_file_path)
        raise e



@contextmanager
def dummy_measure_time(*args, **kwargs):
    yield


@contextmanager
def measure_time(computation_name):
    start_time = time.time()
    print(f'{computation_name}...')
    yield
    elapsed_time = (time.time() - start_time)
    print(f'{computation_name}: completed in {elapsed_time:.1f} seconds')


def count_files_with_extension(directory: Path, extension: str = '.pt') -> int:
    """
    Recursively count files with a specific extension in a directory.

    Args:
        directory: Path to the directory to search in
        extension: File extension to count (including the dot, e.g., '.pt')

    Returns:
        Number of files with the specified extension
    """
    count = 0
    for path in directory.rglob(f'*{extension}'):
        if path.is_file():
            count += 1
    return count


def track_files_progress(
    cache_dir: Path, 
    total_expected: int, 
    extension: str = '.pt',
    update_interval: int = 10,
    stop_event: Optional[threading.Event] = None,
    progress_callback: Optional[Callable[[int, int], None]] = None
):
    """
    (generated by Junie, don't trust this for critical tasks -- or properly check/debug it)

    Track the progress of embeddings computation by counting files in a directory.
    This function is designed to be run in a separate thread.

    Args:
        cache_dir: Directory where embedding files are stored
        total_expected: Total number of expected files
        extension: File extension to count (including the dot, e.g., '.pt')
        update_interval: How often to update the progress (in seconds)
        stop_event: Threading event to signal when to stop tracking
        progress_callback: Optional callback function to handle progress updates
                          If None, a tqdm progress bar will be used
    """
    if stop_event is None:
        stop_event = threading.Event()

    # Create a progress bar if no callback is provided
    pbar = None
    if progress_callback is None:
        pbar = tqdm(total=total_expected, desc=f"Computing {extension} files", unit="file")

    prev_count = 0

    try:
        while not stop_event.is_set():
            current_count = count_files_with_extension(cache_dir, extension)

            # Update progress
            if progress_callback:
                progress_callback(current_count, total_expected)
            elif pbar:
                # Update the progress bar with the difference
                pbar.update(current_count - prev_count)

            prev_count = current_count

            # Check if we're done
            if current_count >= total_expected:
                break

            # Wait for the next update
            stop_event.wait(update_interval)
    finally:
        if pbar:
            pbar.close()
